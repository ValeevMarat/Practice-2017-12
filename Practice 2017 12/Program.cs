using System;

// Задание №12 практики 2017г. 
// Задание 12.3 и 12.5, стр. 11: Выполнить сравнение двух методов сортировки одномерных массивов, содержащих n элементов, по количеству пересылок и сравнений. Провести анализ методов сортировки для трех массивов: упорядоченного по возрастанию, упорядоченного по убыванию и неупорядоченного. 
// Найти в литературе теоретические оценки сложности каждого из методов и сравнить их с оценками, полученными на практике.
// Сделать выводы о том, насколько отличаются теоретические и практические оценки количества операций, объяснить почему это происходит.Сравнить оценки сложности двух алгоритмов.
// 3. Сортировка простыми вставками. 5.	Сортировка с помощью двоичного дерева.
// Задания по учебной практике

namespace Practice_2017_12
{
    class Program
    {
        static Random Rnd=new Random();

        public static int ReadIntegerWithBounds(int lowerBound, int upperBound, string error = "Ошибка, введите значение в допустимых границах!")
        {
            do
            {
                bool ok;       // маркер выхода из цикла
                int input = 0; // переменная для хранения полученного числа

                try
                {
                    input = Convert.ToInt32(Console.ReadLine());
                    ok = input >= lowerBound & input <= upperBound;
                }
                catch (FormatException)
                {
                    Console.Clear();
                    ok = false;
                }
                catch (OverflowException)
                {
                    Console.Clear();
                    ok = false;
                }
                if (ok) return input;
                Console.Clear();
                Console.WriteLine(error);
            } while (true);
        } // Считывание целых чисел по заданным границам (включая их), error - стандартное сообщение для ошибки

        static int[] GenerateAscendingArray(int length)
        {                                  // Кол-во элементов
            int[] arr=new int[length];

            for (int i = 0; i < length; i++)
                arr[i] = i;

            return arr;
        }                                                                                           // Сгенерировать массив по возрастанию от 0 до заданной длины (значения соответсвующие)
        static int[] GenerateDescendingArray(int length)
        {                                  // Кол-во элементов
            int[] arr = new int[length];

            for (int i = 0; i < length; i++)
                arr[i] = length-1-i;

            return arr;
        }                                                                                          // Сгенерировать массив по убыванию от заданной длины до 0 (значения соответсвующие)
        static int[] GenerateRandomArray(int length)
        {                               // Кол-во элементов
            int[] arr = new int[length];

            for (int i = 0; i < length; i++)
                arr[i] =Rnd.Next(length);

            return arr;
        }                                                                                              // Генерация неупорядоченного массива (значения могут повторяться)

        static void InsertionSort(int[] arr, ref int movedAmount, ref int comparedAmount)
        {                        // Массив для сортировки, счётчик перессылок и счётчик сравнений
            for (int i = 1; i < arr.Length; i++)            // С 1, т.к. не требуется сравнивать 0-ой элемент
            {  
                int j = i;                                  // Начинаем с i, т.к. предыдущие элементы уже отсортированы
                for (j=j;j > 0 && arr[j - 1] > arr[j]; j--) // Пока j>0 и элемент j-1 > j
                {      
                    comparedAmount++;
                    int temp = arr[j];
                    arr[j] = arr[j - 1];
                    arr[j - 1] = temp;
                    movedAmount++;
                }
                if (j!=0) comparedAmount++;                 // Если цикл кончился обнулением j, значит сравнение не прошло (IndexOutOfRange)
            }
        }                                                         // Сортировка вставками с счётчиками пересылок и сравнений

        static BinTree Insert(BinTree tree, int el, ref int comparedAmount)
        {                  // Само дерево, элемент для вставки и кол-во сравнений (кол-во пересылок = кол-ву элементу)
            if (tree == null)    // Если дошли до пустого листка, то создаём его
            {
                tree = new BinTree(el);
                return tree;
            }
            comparedAmount++;    // Сравнение с левой веткой
            if (el <= tree.Data) // Слева элементы меньше или равны
            {
                tree.Left = Insert(tree.Left, el,ref comparedAmount);
                return tree;
            }
            comparedAmount++;    // Сравнение с правой веткой
            if (el > tree.Data)  // Справа элементы больше
            {
                tree.Right = Insert(tree.Right, el, ref comparedAmount);
                return tree;
            }
            return null;         // Недостижимый return
        }                                                                       // Вставка элемента в двоичное дерево
        static void BinTreeSort(int[] arr, ref int comparedAmount)
        {                       // Массив с данными и число сравнений (кол-во пересылок всегда равно кол-ву элементов)
            BinTree tree = new BinTree(arr[0]); // Создаём корень из первого элемента
            for (int i = 1; i < arr.Length; i++)
                tree=Insert(tree, arr[i], ref comparedAmount); // Вставляем в дерево каждыц элемент
        }                                                                                // Сортировка двоичным деревом

        static void SortAscendedArray(int arrLength)
        {                           // Кол-во элементов в массиве
            int comparedAmount = 0, movedAmount = 0;                 // Счётчики сравнений и пересылок
            int[] arr = GenerateAscendingArray(arrLength);           // Создаём и заполняем массив данными, упорядоченными по возрастанию

            InsertionSort(arr, ref movedAmount, ref comparedAmount); // Сперва сортировка вставками (требуется клонирование, т.к. элементы в массиве - сслыки => массив отсортируется и в этой функции), затем вывод полученных данных с теорией и объяснение несовпадений
            Console.WriteLine("\n\nСортировка простыми вставками массива упорядоченного по возрастанию (лучшее время: O(n) сравнений, 0 обменов):\nКоличество пересылок = " +
                movedAmount + ", количество сравнений равно = " + comparedAmount +
                " (не совпадает с формулой т.к. O(n-1)=O(n), 1-ый эл. не сравнивается)");

            comparedAmount = 0;

            BinTreeSort(arr, ref comparedAmount);                    // Затем сортировка бинарным деревом. После, вывод полученных данных с теорией и объяснение несовпадений
            Console.WriteLine("\nСортировка двоичным деревом массива упорядоченного по возрастанию  (худшее время (т.к. не сбалансированное и сравнение '>=' идёт после '<'): O(n^2) сравнений, O(n) обменов):\nКоличество пересылок = " +
                arrLength + ", количество сравнений равно = " + comparedAmount +
                " (не совпадает с формулой т.к. O() округляется до O(n^2))");
        }                                                                                              // Сортирует массив, упорядоченный по возрастанию, вставками и бинарным деревом с выводом кол-во пересылок, сравнений, теории и объяснений несовпадений
        static void SortDescendedArray(int arrLength)
        {                           // Кол-во элементов в массиве
            int comparedAmount = 0, movedAmount = 0;                                // Счётчики сравнений и пересылок
            int[] arr = GenerateDescendingArray(arrLength);                         // Создаём и заполняем массив данными, упорядоченными по убыванию

            InsertionSort((int[])arr.Clone(), ref movedAmount, ref comparedAmount); // Сперва сортировка вставками (требуется клонирование, т.к. элементы в массиве - сслыки => массив отсортируется и в этой функции), затем вывод полученных данных с теорией и объяснение несовпадений
            Console.WriteLine("\n\n\nСортировка простыми вставками массива упорядоченного по убыванию (худшее время: O(n^2) сравнений и обменов):\nКоличество пересылок = " +
                movedAmount + ", количество сравнений равно = " + comparedAmount +
                " (не совпадает с формулой т.к. вложенный цикл начинается с i, но O() округляется до O(n^2))");

            comparedAmount = 0;

            BinTreeSort(arr, ref comparedAmount);                                   // Затем сортировка бинарным деревом. После, вывод полученных данных с теорией и объяснение несовпадений
            Console.WriteLine("\nСортировка двоичным деревом массива упорядоченного по убыванию (не лучшее, а среднее время, т.к. дерево не сбалансированное и '<' перед '>=', O(n^2) сравнений, O(n) обменов):\nКоличество пересылок = " +
                arrLength + ", количество сравнений равно = " + comparedAmount +
                " (не совпадает с формулой т.к. O() округляется до O(n^2))");
        }                                                                                             // Сортирует массив, упорядоченный по убыванию, вставками и бинарным деревом с выводом кол-во пересылок, сравнений, теории и объяснений несовпадений
        static void SortRandomArray(int arrLength)
        {                        // Кол-во элементов в массиве
            int comparedAmount = 0, movedAmount = 0;                                // Счётчики сравнений и пересылок
            int[] arr = GenerateRandomArray(arrLength);                             // Создаём и заполняем массив неупорядоченными данными

            InsertionSort((int[])arr.Clone(), ref movedAmount, ref comparedAmount); // Сперва сортировка вставками (требуется клонирование, т.к. элементы в массиве - сслыки => массив отсортируется и в этой функции), затем вывод полученных данных с теорией и объяснение несовпадений
            Console.WriteLine("\n\n\nСортировка простыми вставками неупорядоченного массива (среднее время: O(n^2) сравнений и обменов):\nКоличество пересылок = " +
                movedAmount + ", количество сравнений равно = " + comparedAmount +
                " (не совпадает с формулой т.к. вложенный цикл начинается с i, но O() округляется до O(n^2))");

            comparedAmount = 0;

            BinTreeSort(arr, ref comparedAmount);                                   // Затем сортировка бинарным деревом. После, вывод полученных данных с теорией и объяснение несовпадений
            Console.WriteLine("\nСортировка двоичным деревом неупорядоченного массива (также среднее время):\nКоличество пересылок = " +
                arrLength + ", количество сравнений равно = " + comparedAmount);
        }                                                                                                // Сортирует неупорядоченный массив вставками и бинарным деревом с выводом кол-во пересылок, сравнений, теории и объяснений несовпадений

        static void Main(string[] args)
        {
            Console.Write("Введите кол-во элементов для сортировки (они будут сгенерированы) от 1 до 5000 включительно: ");
            int arrLength = ReadIntegerWithBounds(1, 5000, "Ошибка, введите кол-во элементов от 1 до 5000 включительно!");

            SortAscendedArray(arrLength);  //Сортировка данных упорядоченных по возрастанию
            SortDescendedArray(arrLength); //Сортировка данных упорядоченных по убыванию       
            SortRandomArray(arrLength);    //Сортировка неупорядоченных данных

            Console.ReadKey();
        }                                                                                                           // Сортирует три вида массивов (упорядоченные по возросатния и убыванию, а также неупорядоченные) двумя способами (вставками и бинарным деревом), выводит теоритическую оценку сложности, полученную и объяснение несовпадения
    }
}
